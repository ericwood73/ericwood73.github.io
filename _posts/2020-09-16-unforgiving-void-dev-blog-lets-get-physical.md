---
layout: unforgiving-void-dev-blog-post
title: "Let's Get Physical"
categories: 
  - "unforgiving-void"
  - "dev"
date: 2020-09-16
---
If we are going to have physically realistic space flight, then we're going to need some physics.  Like most game engines, Godot has a physics engine.  My starting point was could I just add forces for the thrusters and the drives and let Godot physics engine figure it out.  There were a couple of problems with this.

First is inertia.  Or more specifically moment of inertia.  The moment of inertia can be though of as a body's tendency to resist rotation just as a body's mass can be though of as a tendency to resist linear motion.  In my game, moment of inertia will be determined by calculating all the contributions of the various modules and their offset from the center of mass of the spaceship.  Physics engines typically use collision shapes to determine moment of inertia.  I think a reason for this is that most of the typical collision shapes (e.g. sphere, box, cylinder) have well known formulas for moment of inertia.  For example, the moment of inertia of a box collision shape about its depth axis is 1/12*mass*(height^2 + width^2).  Similar equations exist for moment of inertia about width and height axes.  So we know the moment of inertia that we want about the body axes, and we have formulas for determining the dimensions for the box collider that will produce that moment of inertia.  Cool, right?  Not so much. The moment of inertia values about each axis are known, but the width depth, and height of the box are not.  This yields 3 equations and 3 unknowns.  Solving a system of 3 quadratic equations and 3 unknowns numerically is certainly doable, but it isn't my idea of a good time.  Incidentally, Unity has an ability to directly specify moment of inertia.  The Godot community has requested the feature, but it hasn't made it into Godot yet.

Second is time.  I want turn based physics with the ability to rewind time, change a thruster setting and advance again.  The Godot physics engines do allow direct manipulation of state; however, physics engines integrate forces, torques, momentum, and velocities over time and I wasn't sure of the potential impacts of instantaneously setting these values.  Also getting everything in the game to not move but retain its momentum and velocity would be pretty challenging, if it was doable at all.

For these reasons I decided to create my own physics simulation.  I didn't need physics based collision so it was really a matter of simulating motion due to forces and torques.  I capture all the relevant state in an object and have a collection of these objects to form a history of the state from the beginning of the turn to the current time.  I am able to step forward in time, building the state history for each physics step.  Then I can rewind by simply discarding the history up until the current time and simulate it again as I step forward.  Using the magic of Godot scenes, I encapsulated this logic into a scene that I can instance under any Spatial and it will move and rotate that spatial according to physics and the forces and torques applied.  This will let me have motion simulation of all ships and torpedoes with a single unified time that can be advanced or rewound.  The entire motion simulation accounts for only around 50 lines of code, which came as a huge surprise to me.  [This](http://www.cs.cmu.edu/~baraff/sigcourse/notesd1.pdf) paper was the primary resource I used; I implemented rotations using the quaternion method it discusses which simplifies a lot of the code.

Testing the simulation has been difficult as my thruster control is very much a work in progress (and the subject of my next post).  I was able to hard code some forces and step time forward and backward and see the ship (or the box that is a proxy for it) move and rotate.  I also tested by advancing and rewinding and changing forces through code and everything seems to be as expected.  It will be hard to tell until I can start working with actual thrusters and realistic masses and thrust forces.  Early in my career I wrote maneuvering simulations for destroyers and the only way to test those was to compare against sea trial results for real destroyers which won't line up exactly due to real world considerations that aren't modeled in the simulation.  It is very hard to debug something when you don't have a clear picture of the expected result.

So for now, I'm going to call the simulation a good baseline and move on to the things that actually generate the forces and torque, the thrusters and the drive.  As is often the case and you will see in the next post, the expectations for the complexity of implementing something often does not align with reality.  The thruster control problem is turning out to be a significant challenge.

See you out there.
