---
layout: unforgiving-void-dev-blog-post
title: "I Like To Move It"
categories: 
  - "unforgiving-void"
  - "dev"
date: 2020-10-31
---
Having sorted out physics, I need to generate forces to make our spacecraft move.  Spacecraft have two types of movement, attitude and translational.  Attitude determines which way the spacecraft is pointing, whereas translational moves the spacecraft along the x, y, and z body axes.  Spacecraft can use gyros for attitude control, or they can use thrusters.  The former can take some time to turn large spacecraft, so for combat maneuvering, we want to use thrusters.  When the main drive is on, thrusters have limited ability to change attitude, so the most common combat maneuvering will be to use attitude thrusters to change attitude with the drive off, then execute a burn to change the velocity vector.  In practice, translational thrusters are not as effective as the main drive in effecting velocity changes, so they are typically only used for rendezvous, docking maneuvers and other scenarios where fine maneuvering is required.  I don’t anticipate these scenarios occurring during combat in Unforgiving Void, but as long as a thruster is aligned with an axis, it can produce a force along that axis, so it is an option available to players.

Spacecraft typically have a lot of thrusters.  Our thrusters are capable of producing variable thrust output, so they have a thrust level setting.  I could allow a player to control the individual thruster settings, but that would likely make the gameplay tedious and wouldn’t be realistic; spacecraft typically have flight computers that fire thrusters to achieve a particular rate of change of attitude or velocity.  My original plan was each thruster would subscribe to a control commend, such as pitch up and all thrusters that were subscribed to a particular commend would fire when that command was given.  While this simplified control of the thrusters, it didn’t really work, because when a counter thrust command was given, say pitch down, the pitch up thrusters would not know to go to 0.  So I introduced the idea of control groups and thrusters would respond to positive and negative commands within the control group.  This solved the problem of zeroing thrust, but created a situation where thrusters could really only be associated with one control group.  If I ordered yaw right, for example, I would fire the port side thrusters forward of the center of mass.  If I ordered 0 yaw and ordered a lateral translation to the right, I would potentially 0 the thruster that I need for the translation maneuver in order to keep forces balanced.  In addition, this system would make it very difficult to implement automatic flight controls such as an automatic nulling of rates or a flight control to attain a particular heading (needed when computing intercepts for rail gun shots).  I realized I needed a Flight Computer.  Now the player commands go to the flight computer and the computer computes the thrust level for each thruster.  At first, I tried to figure out how to automatically set thrust levels to keep the ship balanced during translation maneuvers and how to allocate thrust levels based on the combination of commands.  It turns out most spacecraft flight control systems use a precomputed thruster allocation table that is computed through Pareto optimization to determine the thruster commands for any desired torque and velocity vector.  This was not something I wanted to try to simulate right now, especially given the rarity with which I expect the translational thrusters will be used, so I decided on a simple allocation scheme.  The thruster allocation is determined by simple comparison of the direction of torque produced by that thruster and the thruster vector with each of the body axes.  The thruster is then commended to match the highest level control commend to which the thruster is allocated.  For example, if the thruster is allocated to yaw right and lateral translation to the right, it’s thrust level will be the max of the commanded yaw right level and the commanded right translation level.  Only when both are zero will the thruster cease firing.  In terms of balance, it will be up to the ship designer to ensure that thrusters are placed equidistant from the center of mass to avoid introducing a net torque.  If a thruster is disabled, the player can either disable the balancing thruster
, or can attempt to compensate for the rotational moment during translation movements by applying a torque in the opposite direction.  

So by making some compromises in accuracy for the sake of gameplay, I believe we have a working solution for thrusters and simple flight control.  I may need to revisit when I attempt to add some sort of flight assist or autopilot, but for now, this seems to be workable.

Plugging thrusters into the state management system turned out to be fairly straight forward.  At each state step, the current flight controls are samples and thrust settings are obtained.  These settings are recorded in the state and passed to the thrusters.  The thrusters determine the thrust and this is passed to the motion simulation.  The resulting motion is used to update the ship position and orientation.  When time is rewound or advanced without changes to flight controls, then the flight control settings are restored, sampled, and the sequence is repeated.  While this works, I need to take into account resource usage, i.e. propellant.  This has caused me to rethink how modules work and will require changes to the state management.  That will be the subject of the next blog post.

See you out there.
